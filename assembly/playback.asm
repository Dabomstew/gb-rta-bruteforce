INCLUDE "assembly/hardware_constants.asm"


; The rst vectors are unused.
SECTION "rst 00", ROM0 [$00]
  rst $38
SECTION "rst 08", ROM0 [$08]
  rst $38
SECTION "rst 10", ROM0 [$10]
  rst $38
SECTION "rst 18", ROM0 [$18]
  rst $38
SECTION "rst 20", ROM0 [$20]
  rst $38
SECTION "rst 28", ROM0 [$28]
  rst $38
SECTION "rst 30", ROM0 [$30]
  rst $38
SECTION "rst 38", ROM0 [$38]
  rst $38

; Hardware interrupts
SECTION "vblank", ROM0 [$40]
  reti
SECTION "hblank", ROM0 [$48]
  reti
SECTION "timer",  ROM0 [$50]
  reti
SECTION "serial", ROM0 [$58]
  reti
SECTION "joypad", ROM0 [$60]
  reti


SECTION "Entry", ROM0 [$100]

  nop
  jp Start


SECTION "Header", ROM0 [$104]

  ; The header is generated by rgbfix.
  ; The space here is allocated to prevent code from being overwritten.

  ds $150 - $104



SECTION "Main", ROM0

Start::
  ; Disable LCD (execution starts at VBlank)
  xor a          ; 4 (*2)
  ld [rLCDC], a  ; 12 (*2)

  ; Switch to double speed mode
  ld a, 1        ; 8 (*2)
  ld [rKEY1], a  ; 12 (*2)
  stop           ; 8 (*2)

  ; Init joypad
  xor a          ; 4 ; select buttons and direction keys (makes reading easier)
  ld [rJOYP], a  ; 12

  ; Copy Record method to RAM
  call Tmp_CopyRecord

  ; Start recording inputs
  jp $c000       ; 16



WriteBytes::
; 36 + 52*(len/2) cycles, delay 40,52
  pop hl       ; 12
  pop bc       ; 12
.loop
  pop de       ; 12
  ld a, d      ; 4
  ld [hli], a  ; 8
  ld a, e      ; 4
  ld [hli], a  ; 8
  dec c        ; 4
  jr nz, .loop ; 12/8
  ret          ; 16

FillBytes::
; 40 + 24*len cycles, delay 28
  pop hl       ; 12
  pop bc       ; 12
  ld a, b      ; 4
.loop
  ld [hli], a  ; 8
  dec c        ; 4
  jr nz, .loop ; 12/8
  ret          ; 16

FillBytes2::
; 56 + 8*len + 16*ceil(len/16) cycles, delay 44
  pop hl       ; 12
  pop bc       ; 12
  ld a, b      ; 4
  ret          ; 16
.loop
  rept 16
    ld [hli], a  ; 8
  endr
  dec c        ; 4
  jr nz, .loop ; 12/8
  ret          ; 16



WaitShort:: ; 0 inputs, may delay 100
  rept 21
    nop          ; 4
  endr
  ret          ; 16
WaitLong:: ; 4 inputs, max delay 1051748
  nop          ; 4
  nop          ; 4
  nop          ; 4
  nop          ; 4
  nop          ; 4
  nop          ; 4
; (a-1) * 16 + (b-1) * 4108 + 104
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
.wait
  dec a           ; 4
  jr nz, .wait    ; 12/8
  dec b           ; 4
  jr nz, .wait    ; 12/8
  ret          ; 16


OamDma::
; 680 cycles
  ld a, $d3       ; 8
  ld [$FF46], a   ; 12
  ld a, 40        ; 8 ; 40 * 16 - 4 = 636 cycles
.wait
  dec a           ; 4
  jr nz, .wait    ; 12/8
  ret             ; 16


RecordEasy::
; 76 + len * 60; no 0 inputs
  ld hl, $d000    ; 12
  ld sp, hl       ; 8
  ld c, l ; $00   ; 4
.loop
  ld a, [$ff00+c] ; 8
  swap a          ; 8
  ld d, a         ; 4
  ld a, [$ff00+c] ; 8
  or d            ; 4
  ret z           ; 20/8
  ld [hli], a     ; 8
  jr .loop        ; 12



Record::
; len * 40 + ceil(len/16) * 16 + 128
  ld de, $d000    ; 12
  ld sp, $d000    ; 12
ContinueRecord:: ; len * 40 + ceil(len/16) * 16 + 104
  ld hl, $ff00    ; 12
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld c, a         ; 4
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld [.loop-1-Record+$c000], a ; 16
  jr .loop        ; 12
.loop
  rept 15
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld [de], a      ; 8
  inc de           ; 8 ;; inc e?
  endr
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld [de], a      ; 8
  inc de          ; 8
  dec c           ; 4
  jr nz, .loop    ; 12/8
  ret             ; 16

Tmp_CopyRecord::
  ld hl, Record
  ld de, $c000
  ld c, Tmp_CopyRecord - Record
.loop
  ld a, [hli]
  ld [de], a
  inc de
  dec c
  jr nz, .loop
  ret



WriteTile::    ; 316, 9 payload frames, 0 inputs, delay 28,40 + i*36
  pop hl       ; 12
  rept 8
  pop bc       ; 12
  ld a, b      ; 4
  ld [hli], a  ; 8
  ld a, c      ; 4
  ld [hli], a  ; 8
  endr
  ret          ; 16

WriteTileDirect:: ; 656, 0 payload frames, 35 inputs (68 + {0,16} + 36*i), outputs 92 - 632
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  and $f       ; 8
  swap a       ; 8
  ld c, a      ; 4
  rept 15
    ld a, [hl]   ; 8
    swap a       ; 8
    xor [hl]     ; 8
    ld [bc], a   ; 8
    inc c        ; 4
  endr
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  ret          ; 16

WriteTileDirectVram0:: ; 672, 0 payload frames, 35 inputs (68 + {0,16} + 36*i), outputs 92 - 632
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  and $f       ; 8
  swap a       ; 8
  ld c, a      ; 4
  rept 15
    ld a, [hl]   ; 8
    swap a       ; 8
    xor [hl]     ; 8
    ld [bc], a   ; 8
    inc c        ; 4
  endr
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  xor a        ; 4
  ld [$ff4f], a ; 12
  ret          ; 16

WriteTileDirectVram1:: ; 672, 0 payload frames, 35 inputs (68 + {0,16} + 36*i), outputs 92 - 632
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  and $f       ; 8
  swap a       ; 8
  ld c, a      ; 4
  rept 15
    ld a, [hl]   ; 8
    swap a       ; 8
    xor [hl]     ; 8
    ld [bc], a   ; 8
    inc c        ; 4
  endr
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  ld a, h ;$ff ; 4
  ld [$ff4f], a ; 12
  ret          ; 16



WriteBgPaletteDirect:: ; 328, 18 inputs (20, 36, 56 + {0,16} + 32*i), outputs 80 - 304
  ld hl, $ff00    ; 12
  ld c, $68       ; 8
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld [$ff00+c], a ; 8
  inc c           ; 4
  rept 8
    ld a, [hl]      ; 8
    swap a          ; 8
    xor [hl]        ; 8
    ld [$ff00+c], a ; 8
  endr
  ret             ; 16



WriteByte::    ; 48, 2 payload frames, 0 inputs, delay 24
  pop hl       ; 12
  pop af       ; 12
  ld [hl], a   ; 8
  ret          ; 16

WriteByteHalfDirect:: ; 72, 1 payload frame, 2 inputs (24,40), delay 48
  ld hl, $ff00 ; 12
  pop bc       ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  ret          ; 16

WriteByteDirect:: ; 116, 0 payload frames, 6 inputs (12 + {0,16} + i*28), outputs 92
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld c, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  ret          ; 16

WriteByteDirectVram0:: ; 132, 0 payload frames, 6 inputs (12 + {0,16} + i*28), outputs 92
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld c, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  xor a        ; 4
  ld [$ff4f], a ; 12
  ret          ; 16

WriteByteDirectVram1:: ; 132, 0 payload frames, 6 inputs (12 + {0,16} + i*28), outputs 92
  ld hl, $ff00 ; 12
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld b, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld c, a      ; 4
  ld a, [hl]   ; 8
  swap a       ; 8
  xor [hl]     ; 8
  ld [bc], a   ; 8
  ld a, h ;$ff ; 4
  ld [$ff4f], a ; 12
  ret          ; 16



WriteHByte::      ; 40, 1 payload frame, 0 inputs, delay 16
  pop bc          ; 12
  ld a, b         ; 4
  ld [$ff00+c], a ; 8
  ret             ; 16

WriteHByteDirect:: ; 88, 0 payload frames, 4 inputs (12,28,40,56), outputs 64
  ld hl, $ff00    ; 12
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld c, a         ; 4
  ld a, [hl]      ; 8
  swap a          ; 8
  xor [hl]        ; 8
  ld [$ff00+c], a ; 8
  ret             ; 16

